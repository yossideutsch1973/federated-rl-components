<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ðŸŽ¯ Multi-Task Learning: Circle + Slalom</title>
    <style>
        body { 
            margin: 0; 
            padding: 20px; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff; 
            font-family: monospace; 
        }
        #app { max-width: 1800px; margin: 0 auto; }
    </style>
</head>
<body>
    <div id="app"></div>
    <script type="module">
        /**
         * MULTI-TASK CONTINUAL LEARNING
         * 
         * Learns BOTH circle control AND slalom navigation
         * WITHOUT forgetting either skill!
         * 
         * Strategy: Alternating task episodes
         *   - Episode N: Circle task
         *   - Episode N+1: Slalom task
         *   - Shared Q-table with task-specific state encoding
         * 
         * State encoding: "TASK_ID:state_features"
         *   - Circle: "C:error,angle,vel"
         *   - Slalom: "S:relX,relY,vel"
         */

        import { createFederatedApp } from '../components/app-template.js';
        import { discretize } from '../components/rl-core.js';
        import { createLiveControls } from '../components/live-controls.js';

        const CONFIG = {
            strengthMed: 50000,
            strengthHigh: 100000,
            friction: 0.88,
            maxVelocity: 15,
            maxSteps: 1000,
            alpha: 0.2,
            gamma: 0.95,
            epsilon: 0.3,
            epsilonDecay: 0.995,
            minEpsilon: 0.01,
            
            // Multi-task specific
            circleWeight: 0.5,  // 50% circle, 50% slalom episodes
            targetRadius: 100,
            errorThreshold: 15,
            
            // Performance
            renderInterval: 50
        };

        const PHYSICS_CONFIG = {
            get strengthLevels() { return [0, CONFIG.strengthMed, CONFIG.strengthHigh]; },
            minDistance: 30,
            get friction() { return CONFIG.friction; },
            get maxVelocity() { return CONFIG.maxVelocity; },
            flagRadius: 25,
            dt: 1.0
        };

        const MAGNETS = [
            {x: 200, y: 20}, {x: 340, y: 60}, {x: 380, y: 200}, {x: 340, y: 340},
            {x: 200, y: 380}, {x: 60, y: 340}, {x: 20, y: 200}, {x: 60, y: 60}
        ];

        const PATTERNS = [
            [0,0,0,0,0,0,0,0], [1,0,0,0,0,0,0,0], [0,0,1,0,0,0,0,0], 
            [0,0,0,0,1,0,0,0], [0,0,0,0,0,0,1,0], [0,1,0,0,0,0,0,0], 
            [0,0,0,1,0,0,0,0], [0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1]
        ];

        const ACTIONS = [];
        const STRENGTH_NAMES = ['OFF', 'MED', 'HIGH'];
        const PATTERN_NAMES = ['OFF', 'N', 'E', 'S', 'W', 'NE', 'SE', 'SW', 'NW'];
        
        for (let p = 0; p < PATTERNS.length; p++) {
            for (let s = 0; s < 3; s++) {
                ACTIONS.push({
                    pattern: PATTERNS[p],
                    strength: s,
                    id: ACTIONS.length,
                    name: `${PATTERN_NAMES[p]}-${STRENGTH_NAMES[s]}`
                });
            }
        }

        // ====================================================================
        // PHYSICS (SHARED)
        // ====================================================================

        const applyMagneticForces = (state, action) => {
            let fx = 0, fy = 0;
            const magnetStrength = PHYSICS_CONFIG.strengthLevels[action.strength];
            
            action.pattern.forEach((magnetOn, i) => {
                if (!magnetOn) return;
                const mag = MAGNETS[i];
                const dx = mag.x - state.x;
                const dy = mag.y - state.y;
                const r = Math.max(Math.hypot(dx, dy), PHYSICS_CONFIG.minDistance);
                const forceMag = magnetStrength / (r * r);
                fx += forceMag * dx / r;
                fy += forceMag * dy / r;
            });
            
            let vx = state.vx * PHYSICS_CONFIG.friction + fx * PHYSICS_CONFIG.dt;
            let vy = state.vy * PHYSICS_CONFIG.friction + fy * PHYSICS_CONFIG.dt;
            
            const vMag = Math.hypot(vx, vy);
            if (vMag > PHYSICS_CONFIG.maxVelocity) {
                const scale = PHYSICS_CONFIG.maxVelocity / vMag;
                vx *= scale;
                vy *= scale;
            }
            
            let x = state.x + vx;
            let y = state.y + vy;
            
            if (x < 10) { x = 10; vx = 0; }
            if (x > 390) { x = 390; vx = 0; }
            if (y < 10) { y = 10; vy = 0; }
            if (y > 390) { y = 390; vy = 0; }
            
            return { x, y, vx, vy, fx, fy };
        };

        // ====================================================================
        // TASK-SPECIFIC STATE ENCODING
        // ====================================================================

        const stateToKeyCircle = (state) => {
            const error = state.circleError || 0;
            const angle = Math.atan2(state.y - 200, state.x - 200);
            const vMag = Math.hypot(state.vx, state.vy);
            
            const e = discretize(error, 5, 0, 100);
            const a = discretize(angle, 8, -Math.PI, Math.PI);
            const v = discretize(vMag, 3, 0, 15);
            
            return `C:${e},${a},${v}`;  // C = Circle task
        };

        const stateToKeySlalom = (state) => {
            if (!state.flags || !state.flags[state.currentFlag]) return 'S:0,0,0,0';
            
            const flag = state.flags[state.currentFlag];
            const relX = flag.x - state.x;
            const relY = flag.y - state.y;
            const vMag = Math.hypot(state.vx, state.vy);
            const vDir = Math.atan2(state.vy, state.vx);
            
            const rx = discretize(relX, 5, -200, 200);
            const ry = discretize(relY, 5, -200, 200);
            const vm = discretize(vMag, 3, 0, 15);
            const vd = discretize(vDir, 4, -Math.PI, Math.PI);
            
            return `S:${rx},${ry},${vm},${vd}`;  // S = Slalom task
        };

        // ====================================================================
        // MULTI-TASK ENVIRONMENT
        // ====================================================================

        const environment = {
            actions: ACTIONS,
            
            getState: (state) => {
                if (state.taskType === 'circle') {
                    return stateToKeyCircle(state);
                } else {
                    return stateToKeySlalom(state);
                }
            },
            
            step: (state, actionIdx) => {
                const action = ACTIONS[actionIdx];
                const newPhysics = applyMagneticForces(state, action);
                
                if (state.taskType === 'circle') {
                    // Circle task logic
                    const dist = Math.hypot(newPhysics.x - 200, newPhysics.y - 200);
                    const error = Math.abs(dist - CONFIG.targetRadius);
                    
                    const newState = {
                        ...state,
                        ...newPhysics,
                        circleError: error,
                        steps: state.steps + 1,
                        timeOnCircle: error < CONFIG.errorThreshold ? 
                            state.timeOnCircle + 1 : state.timeOnCircle
                    };
                    
                    // Circle reward
                    let reward = -error * 0.5;
                    reward -= 0.1;  // Time penalty
                    const activeMagnets = action.pattern.filter(m => m === 1).length;
                    reward -= 0.01 * activeMagnets * (action.strength + 1);
                    if (error < CONFIG.errorThreshold) reward += 10;
                    
                    const done = state.steps > CONFIG.maxSteps;
                    return { state: newState, reward, done };
                    
                } else {
                    // Slalom task logic
                    let currentFlag = state.currentFlag;
                    const flag = state.flags[currentFlag];
                    
                    if (flag) {
                        const dist = Math.hypot(newPhysics.x - flag.x, newPhysics.y - flag.y);
                        if (dist < PHYSICS_CONFIG.flagRadius) {
                            currentFlag++;
                        }
                    }
                    
                    const newState = {
                        ...state,
                        ...newPhysics,
                        currentFlag,
                        steps: state.steps + 1
                    };
                    
                    // Slalom reward
                    let reward = -0.1;
                    const activeMagnets = action.pattern.filter(m => m === 1).length;
                    reward -= 0.01 * activeMagnets * (action.strength + 1);
                    
                    if (newState.currentFlag > state.currentFlag) {
                        reward += 100;
                    } else if (flag) {
                        const dist = Math.hypot(newState.x - flag.x, newState.y - flag.y);
                        reward += 5 * (1 - dist / 400);
                    }
                    
                    const done = currentFlag >= state.flags.length || state.steps > CONFIG.maxSteps;
                    return { state: newState, reward, done };
                }
            },
            
            reset: (clientId, oldState) => {
                // Alternate between tasks
                const shouldBeCircle = Math.random() < CONFIG.circleWeight;
                
                if (shouldBeCircle) {
                    // Reset to circle task
                    const randomAngle = Math.random() * Math.PI * 2;
                    const randomRadius = CONFIG.targetRadius + (Math.random() - 0.5) * 40;
                    
                    return {
                        taskType: 'circle',
                        x: 200 + randomRadius * Math.cos(randomAngle),
                        y: 200 + randomRadius * Math.sin(randomAngle),
                        vx: 0, vy: 0, fx: 0, fy: 0,
                        circleError: Math.abs(randomRadius - CONFIG.targetRadius),
                        steps: 0,
                        timeOnCircle: 0
                    };
                } else {
                    // Reset to slalom task
                    const flags = [];
                    for (let i = 0; i < 8; i++) {
                        flags.push({
                            x: 100 + Math.random() * 200,
                            y: 50 + i * 40
                        });
                    }
                    
                    return {
                        taskType: 'slalom',
                        x: 200, y: 200,
                        vx: 0, vy: 0, fx: 0, fy: 0,
                        flags,
                        currentFlag: 0,
                        steps: 0
                    };
                }
            }
        };

        // ====================================================================
        // RENDERING (TASK-AWARE)
        // ====================================================================

        const render = (ctx, state, client) => {
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, 400, 400);
            
            const actionIdx = client.lastAction !== undefined ? client.lastAction : 0;
            const action = ACTIONS[actionIdx];
            
            // Draw task-specific visuals
            if (state.taskType === 'circle') {
                // Target circle
                ctx.strokeStyle = '#22c55e';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(200, 200, CONFIG.targetRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Tolerance band
                ctx.strokeStyle = 'rgba(34, 197, 94, 0.3)';
                ctx.lineWidth = CONFIG.errorThreshold * 2;
                ctx.beginPath();
                ctx.arc(200, 200, CONFIG.targetRadius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Task label
                ctx.fillStyle = '#fbbf24';
                ctx.font = 'bold 16px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('CIRCLE TASK', 200, 30);
            } else {
                // Flags
                state.flags.forEach((flag, i) => {
                    const passed = i < state.currentFlag;
                    const current = i === state.currentFlag;
                    
                    if (passed) {
                        ctx.strokeStyle = '#10b981';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(flag.x, flag.y, 20, 0, Math.PI * 2);
                        ctx.stroke();
                    } else {
                        ctx.fillStyle = current ? '#22c55e' : '#64748b';
                        ctx.beginPath();
                        ctx.arc(flag.x, flag.y, 20, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#fff';
                        ctx.font = '12px monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText(i + 1, flag.x, flag.y + 4);
                    }
                });
                
                // Task label
                ctx.fillStyle = '#3b82f6';
                ctx.font = 'bold 16px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('SLALOM TASK', 200, 30);
            }
            
            // Draw magnets
            const magnetLabels = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
            MAGNETS.forEach((mag, i) => {
                const active = action.pattern[i] === 1 && action.strength > 0;
                
                if (active) {
                    const glowSize = 35 + action.strength * 8;
                    ctx.fillStyle = action.strength === 1 ? 
                        'rgba(251, 191, 36, 0.7)' : 
                        'rgba(239, 68, 68, 0.8)';
                    ctx.beginPath();
                    ctx.arc(mag.x, mag.y, glowSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = action.strength === 1 ? '#fbbf24' : '#ef4444';
                } else {
                    ctx.fillStyle = 'rgba(30, 41, 59, 0.5)';
                }
                
                ctx.beginPath();
                ctx.arc(mag.x, mag.y, 12, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = active ? '#ffffff' : '#64748b';
                ctx.font = '10px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(magnetLabels[i], mag.x, mag.y);
            });
            
            // Draw object
            const onTarget = state.taskType === 'circle' ? 
                state.circleError < CONFIG.errorThreshold : 
                false;
            ctx.fillStyle = onTarget ? '#22c55e' : '#3b82f6';
            ctx.beginPath();
            ctx.arc(state.x, state.y, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Stats
            ctx.fillStyle = '#fff';
            ctx.font = '11px monospace';
            ctx.textAlign = 'left';
            
            if (state.taskType === 'circle') {
                ctx.fillText(`Error: ${state.circleError.toFixed(1)}px`, 10, 380);
                ctx.fillText(`On Circle: ${(state.timeOnCircle / Math.max(1, state.steps) * 100).toFixed(0)}%`, 10, 395);
            } else {
                ctx.fillText(`Flags: ${state.currentFlag}/8`, 10, 380);
                ctx.fillText(`Progress: ${Math.round(state.currentFlag / 8 * 100)}%`, 10, 395);
            }
        };

        // ====================================================================
        // CREATE APP
        // ====================================================================

        console.log('ðŸŽ¯ Multi-Task Continual Learning');
        console.log('Tasks: Circle Control + Slalom Navigation');
        console.log('Strategy: Alternating episodes, shared Q-table');
        console.log('State encoding: Task-prefixed ("C:" or "S:")');
        console.log('Total state space: ~120 (circle) + ~300 (slalom) = ~420 states');

        const app = createFederatedApp({
            name: 'ðŸŽ¯ Multi-Task Learning',
            subtitle: 'Circle + Slalom â€¢ Shared Q-table â€¢ No forgetting',
            
            numClients: 4,
            canvasWidth: 400,
            canvasHeight: 400,
            renderInterval: CONFIG.renderInterval,
            
            alpha: CONFIG.alpha,
            gamma: CONFIG.gamma,
            epsilon: CONFIG.epsilon,
            epsilonDecay: CONFIG.epsilonDecay,
            minEpsilon: CONFIG.minEpsilon,
            
            autoFederate: false,
            federationInterval: 50,
            
            environment,
            render,
            
            onEpisodeEnd: (client, completedEpisode) => {
                const qSize = Object.keys(client.agent.getModel()).length;
                const taskEmoji = client.state.taskType === 'circle' ? 'â­•' : 'ðŸŽ¯';
                
                if (client.state.taskType === 'circle') {
                    const successRate = (client.state.timeOnCircle / client.state.steps * 100).toFixed(0);
                    console.log(`${taskEmoji} Client ${client.id} Circle: ${successRate}% on target, Q: ${qSize} states`);
                } else {
                    const flagRate = Math.round(client.state.currentFlag / 8 * 100);
                    console.log(`${taskEmoji} Client ${client.id} Slalom: ${client.state.currentFlag}/8 flags (${flagRate}%), Q: ${qSize} states`);
                }
            }
        });
        
        setTimeout(() => {
            createLiveControls(app, CONFIG);
        }, 500);
    </script>
</body>
</html>

